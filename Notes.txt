Gotchas:
- structural operations are deferred (Add/Remove/Create/Destroy)
- trying to query a component type directly rather than using 'Read<T>' or 'Write<T>'
- forgetting to put a 'ref' on a parameter that mutates a component or resource
	: enforced by the Visual Studio extension
- forgetting 'ref' when declaring a variable that unwraps a 'Write<T>'
	: enforced by the Visual Studio extension
- forgetting to add Nodes.Default in the controller sequence
- nesting generics deeper than 6 (limit is 7 but 1 nesting depth is needed internally)
- users need to have dotnet core 2.1 installed for the generator to work
	: added error message

Conventions:
- reactions should not be used when an equivalent solution exists
- use 'On' or 'Do' prefix when defining a message
- use 'Is', 'Has', 'Will' or 'Was' prefix when defining a tag

Frictions:
- no default values (for components, messages, resources, systems)
	: components and resources can now use the 'DefaultAttribute'
- can not add a component/resource by dragging the file on a gameObject

Features:
- support for component operations over interfaces and generic definitions
	- ex:
		interface IFreezeSource : IComponent {}
		struct TimedFreeze : IFreezeSource { public float Remaining; }
		struct InputFreeze : IFreezeSource { public KeyCode[] Keys; public int Remaining; }
		struct RegionFreeze : IFreezeSource { }
		if (Components.Has<IFreezeSource>()) // Do not update motion, or take double damage, etc.
	- ex:
		[None(typeof(Unity<>))] // Filters out entities that have any concretisation of the generic definition
		Group<Entity> Group;
	- compatible operations include:
		- Components.Has
		- Components.Count
		- Components.Remove
		- Components.Clear
		- [All], [Any], [None]
	- incompatible operations include:
		- Components.Set
		- Components.Get // and other getters
		- Group<T>
		- Segment.Store
	- for generic API calls, the compiler will be able to ensure a concrete vs abstract generic argument
	- concrete types will have to be registered with all their related abstract types
		- struct Unity<T> : IUnity { }
		- ComponentUtility.Cache<T>.Data will need an indirection to allow the metadata to be changed
		- ComponentUtility.Cache<T> could get an 'Index' field since it is usually what is used and the index will never change
			- the index will actually be required for the indirection to work
- interpret generic definition dependencies correctly
	- ex: new Dependencies.Emit(typeof(Messages.OnAdd<>))
	- this should mean that there is an emit dependency on every type 'T' that fits in 'Messages.OnAdd<>'
- interpret interface dependencies correctly
	- new Dependencies.Write(typeof(IComponent))
	- this should mean that there is a write dependency on every type that implements 'IComponent'
- allow exclusive queries to run in parallel
	- ex: 
		[All(typeof(B))] Group<Write<A>> GroupA; // defined in 'SystemA'
		[None(typeof(B))] Group<Write<A>> GroupB; // defined in 'SystemB'
	- 'SystemA' and 'SystemB' should be allowed to run in parallel
	- they are safe because they will have no common segments even though they both have a write dependency on 'A'
- add tests for 'Resolvers' module
- make Components.Set / Components.Remove / Entities.Create / Entities.Destroy thread safe?
	- this might be very hard or impossible to accomplish without locking

- improve better removal actions in tests by querying all removable entities from the world and choosing from that query
	- currently, a random entity is chosen from the world and if it is not removable, the action is considered invalid
	- this makes removal actions much less often successful, thus it reduces the overall effectiveness of the sequences
	- it also skews the chosen probabilities in favor of add actions
- built-in Hierarchy component
	- should use an 'IndexStore' since it needs to be fast for entity queries and will most likely be very common
	: should not be a component, but a module since changes to one hierarchy must echo throughout the other related hierarchies
- write property and performance tests
	- C# QuickCheck implementation: https://github.com/fscheck/FsCheck/
	- run tests on device with IL2CPP build

Bugs:
- error in Unity when renaming a component/resource.
	- the error prevents to go in play mode while it is there
	- the error disapears on the next compilation
	: the error appears in the console but is removed when compilation is done
- if a new arbitrary type is defined outside the generator's input folders and then used in a component, the generator will try to look for that type in the assembly that Unity compiles but will fail to find it since Unity didn't get a chance to compile it; then the generator will generate a component with a potentially wrongly named type which will prevent Unity from compiling
	- currently a user has to manually repair the broken type reference to give Unity a chance to compile, after which the generator will properly find the type
	- a potential solution is to include all files as input to the generator
		- the performance hit might be reduced by not having to include 'ScriptAssemblies'
		- the generator would be triggered only when a file within the input folders is modified but would take all the project files as input
	- otherwise, the generator can try to generate using the input folders, but if a reference cannot be resolved, it could retry using all the project files
		- in most cases, the generator succeeds without needing all the files, so the performance hit should occur only in rare cases
- Instantiation/Initialization can get stuck in an inifinite loop
- If 2 components of the same name but in different namespaces are included in a query, the generator will generate ambiguous extensions
	-ex: Group<All<Components.Boba.A, Components.Fett.A>>; item.A();
	- would require adding namespace elements to the extensions until they are no longer ambiguous; item.BobaA(); item.FettA();

Optimization:
- Components.HasAll<T1, T2, ...>, Components.HasAny<T1, T2, ...>, Components.HasNone<T1, T2, ...>
	- would retrieve a statically cached mask that represents all generic types
	- would resolve in a single BitMask comparison rather than multiple separate ones
	- could be done using a tuple type rather than a bagillion overloads
		- ex: Components.HasAll<(Boba, Fett)>()
		- I need the 'ITuple' interface to appropriately constrain the generic argument, but it exists only in .Net Standard 2.1
- do not reserve a store for empty components
- WorldReferenceEditor is very slow. Can try to cache stuff.
- make sure every 'Enumerable<T>' is implemented in such a way that it doesn't allocate 
	- especially check stores

Questions:
- should system methods be implemented explicitly by convention?
	- prevents cases where a user changes the system interfaces and doesn't understand why the methods are not called anymore since the compiler will emit an error
- instead of having Queryables.Read<T>, Dependables.Read<T> and Queriers.Read<T>, etc. include the others inside the main one?
	- Queryables.Read<T> would have an inner class called Dependable and one called Querier, etc.
- merge Dependables.Read<T> and Queryable.Read<T>?
- how to instantiate efficiently entities and entity references?
	- in the 'Templates' module, one should be able to exchange an Entity, an EntityReference or a TemplateReference with a 'Template'
	- the TemplateReference will have 2 options: 'Pure' and 'Pool'
		- 'Pure' indicates that only the Entia elements should be considered in the produced template, thus stripping away all the Unity hierarchy
		- if 'Pure' is false, the Unity hierarchy will be instantiated and all Entia references will be stripped (in debug, EntityReference will remain to display their components)
		- 'Pool' indicates that the Unity hierarchy should be pooled to limit the instantiations; note that this requires proper initialization of Unity components
- how to allow to display the System's state?
	- since the system instances are hidden, there is no way to retrieve them from outside
	- even if one had a reference to a system, all system state is forced to be private, thus still inaccessible
	- Solution 1:
		- create a 'Systems' module that gives access to active system instances
		- allow a system to expose its state publicly
			- should properties be used to differenciate from injected fields?
			- should an attribute be used to ignore the injection of some fields (opt-out injection)?
			- should an attribute be used to inject fields (opt-in injection)?
		- this allows a separate MonoBehaviour to retrieve the system and its state and display it
	- Solution 2:
		- store the state to display in a 'Resource'
		- since all fields are meant to be public in a resource, a separate MonoBehaviour will be able to display the state
		- this exposes the state to all systems but is more inline with Entia
- find a better way to enable/disable profiling than using Application.isEditor?
- leave 'Controller' state wrappers in builds?
	- the performance cost might not be worth any effort
	- could be useful to be able to disable a system in a build
- better way to initialize the World
	- currently using a Factory in WorldReference but it seems that there might be a better pattern
- systems as structs...
	- since C# has a poor type inference for functions, it is more lightweigth to register systems like so: Build<ASystem>() vs Build<ASystem.Data>(ASystem.Run)
	- allows to add a dispose mechanism and/or other system events
	- data can be accessed directly through fields rather than 'data.Something'
	- data in systems is less protected
		- public fields will have to be providable
		- private fields will be ignored
		- this way, a non-providable public field that tries to expose the system's data to the outside world, will fail on provision
	- will make automatic instantiation possible
		- very practical for prototyping
		- ordering will have to be definable manually
- special Disabled<T> where T : IComponent tag that disables specific components?
	- Read<T> and Write<T> queries will implicitly exclude Disabled<T>
	- doubles the number of component indices
	- Read<T> and Write<T> will have to add it to their static Filter
- generate deconstructors for ISystemData?
- how to improve the 'TryGet' flow
	- can I somehow return a ref?
- how to remove static interfaces?
	- The main reason they exist is for insuring proper AOT compilation
	- Maybe this AOT issues could be resolved via code generation?
- Unity defer?
				
- parameterized templates?
	- templates could require arguments when instantiated in order to set some required values on components
	- another idea would be to allow to require an 'out Write<T>' to initialize to component
		- would be able to skip the dictionary lookup
		- much more general solution than the previous one
		- what happens if the template did not have a 'T' type?
			- could return an 'out Write<T>?' instead to represent nullability
			
- is separating 'Read' and 'Write' really useful?
	- it makes dependencies more obvious and 'might' allow for some automatic scheduling of systems and/or prevention of race conditions
	- in debug, the ComponentManager could check if two thread are trying to write to the same component types
		- when iterating a group, it would have to notify the ComponentManager that a given thread is reading/writing to a set of types
		- 'GetEnumerator' would call 'WriteLock(types)' and/or 'ReadLock(types)' and 'Dispose' would call 'WriteUnlock(types)' and/or 'ReadUnlock()'
		- 'WriteLock' and 'ReadLock' could also return a 'Lock' struct that would have to be disposed
		- might not be needed if dependencies are declared properly (see "use the function parameters of a system for dependency declarations?")
	- performance-wise it makes no difference in Production
	- all dependencies can be 'Write' by default and can be specified to be 'Read'

Rejected:
- make Read<T> and Write<T> delegates
	- this would make the syntax more lightweight
		- ex: ref var position = item.Item1.Value; /*becomes*/ ref var position = item.Item1();
	- since the getter of the property 'Value' is a function, it might not make a performance difference
		- measure it in case of compiler optimizations
	- requires a way
	: wouldn't work properly with '?' types since delegates are not structs; it would mean that nullability would be hidden
	
Answers:
- should I keep 'ISystem' mandatory or system interfaces should derive from it?
	: it is useless to write it everytime and since the interfaces are already specific to systems, lets just make the dependency explicit and save some boilerplate code
- external project vs Unity project
	: External project:
		- C#7 features
			- 'is var'
			- 'out var'
			- 'ref' returns and locals
			- 'ref readonly' returns and locals
			- better extension resolution 
				- component named extensions do work
				- we don't have to use index-based unpacking of group items (First, Second, etc.)
			- tuple syntax (construction and deconstruction)
		- More scattered
			- extensions and generated components must go in 2 different projects
				- we want the extensions to be usable within the external project
				- we want generated components to remain in script files in Unity such that they each have a specific meta
			- enforces that we don't use the generated components in the game code
			- will sometimes require to have 2 Visual Studio instances opened at the same time
			- more complexity from managing 2 Visual Studio solutions
		- Would most likely be a temporary setup that would be dismantled when C#7 becomes available in Unity
		- Better code stripping
			- Unity strips code from external DLLs
			- Unity doesn't strip code from script files
			- The amount of generated extensions doesn't matter since the unused ones will be stripped
			- Relies on the fact that we use stripping and that it works properly
		- Detecting renames is complicated
			- I have no good way to semantically map declared components to their generated components since they are in different DLLs
			- I might have to generate mapping C# files in the external project that would get compiled with the DLL
				- The mappings might get stripped by Unity though
		- Can't use Unity's #if directives
			- Enforces that we correctly separate editor code from non-editor code
			- Requires that platform specific code is placed in the Unity project or that it uses a runtime check

- support for multiple components of the same type?
	: might not be really useful, but since it doesn't hinder a big performance cost, I've left it there