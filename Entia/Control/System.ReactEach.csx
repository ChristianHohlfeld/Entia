IEnumerable<(string system, string scheduler, string depender)> Generate(int depth)
{
    static IEnumerable<string> GenericParameters(int count)
    {
        if (count == 1) yield return "T";
        else for (var i = 1; i <= count; i++) yield return $"T{i}";
    }

    const string message = "TMessage";
    for (int i = 0; i <= depth; i++)
    {
        var generics = GenericParameters(i).ToArray();
        var parameters = $"<{string.Join(", ", generics.Prepend(message))}>";
        var refs = i == 0 ? "" : string.Join("", generics.Select((generic, index) => $", ref {generic} component{index + 1}"));
        var constraints = string.Join("", generics
            .Select(generic => $" where {generic} : struct, IComponent")
            .Prepend($" where {message} : struct, IMessage"));
        var queryable =
            i == 0 ? "Entity" :
            i == 1 ? $"Write<{generics[0]}>" :
            $"All<{string.Join(", ", generics.Select(generic => $"Write<{generic}>"))}>";
        var storeVars = string.Join(" ", generics.Select((generic, index) => $"var store{index + 1} = segment.Store<{generic}>();"));
        var storeRefs = string.Join("", generics.Select((generic, index) => $", ref store{index + 1}[j]"));
        var concats = string.Join(
            Environment.NewLine + "            ",
            generics.Select(generic => $".Concat(context.Dependencies<Write<{generic}>>())"));

        yield return (
$@"    public interface IReactEach{parameters} : ISystem, IImplementation<Schedulers.ReactEach{parameters}>, IImplementation<Dependers.ReactEach{parameters}>{constraints}
    {{
        void React(in {message} message, Entity entity{refs});
    }}",
$@"    public sealed class ReactEach{parameters} : Scheduler<IReactEach{parameters}>{constraints}
    {{
        delegate void Run(in {message} message, Entity entity{refs});

        public override Type[] Phases => React.Phases<{message}>();

        public override Phase[] Schedule(in IReactEach{parameters} instance, in Schedule.Context context)
        {{
            var world = context.World;
            var react = new Run(instance.React);
            var box = world.Segments<{queryable}>(react.Method);
            return React.Schedule<{message}>(Phase.From((in Phases.React<{message}> phase) =>
            {{
                var segments = box.Value.Segments;
                for (int i = 0; i < segments.Length; i++)
                {{
                    var segment = segments[i];
                    var (entities, count) = segment.Entities;
                    {storeVars}
                    for (int j = 0; j < count; j++) react(phase.Message, entities[j]{storeRefs});
                }}
            }}), context.Controller, context.World);
        }}
    }}",
$@"    public sealed class ReactEach{parameters} : IDepender{constraints}
    {{
        public IEnumerable<IDependency> Depend(in Dependency.Context context) => new IDependency[] {{ new Read(typeof(Entity)), new React(typeof({message})) }}
            {concats};
    }}");
    }
}

var file = "System.ReactEach";
var results = Generate(6).ToArray();
var code =
$@"/* DO NOT MODIFY: The content of this file has been generated by the script '{file}.csx'. */

using Entia.Core;
using Entia.Systems;
using System;
using Entia.Modules.Schedule;
using Entia.Modules.Query;
using Entia.Queryables;
using System.Collections.Generic;
using Entia.Dependencies;
using System.Linq;

namespace Entia.Systems
{{
{string.Join(Environment.NewLine, results.Select(result => result.system))}
}}

namespace Entia.Schedulers
{{
{string.Join(Environment.NewLine, results.Select(result => result.scheduler))}
}}

namespace Entia.Dependers
{{
{string.Join(Environment.NewLine, results.Select(result => result.depender))}
}}";

File.WriteAllText($"./{file}.cs", code);