/* DO NOT MODIFY: The content of this file has been generated by the script 'Node.Inject.csx'. */

using System;
using Entia.Core;
using Entia.Injectables;
using Entia.Injection;
using Entia.Dependency;

namespace Entia.Experimental
{
    public sealed partial class Node
    {
        public static Node Inject<T>(Func<T, Node> provide) where T : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T>();
            if (result1.TryValue(out var value1))
                return provide(value1).Depend(new[] { world.Dependencies<T>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages()));
        }));
        public static Node Inject<T1, T2>(Func<T1, T2, Node> provide) where T1 : IInjectable where T2 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2))
                return provide(value1, value2).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages()));
        }));
        public static Node Inject<T1, T2, T3>(Func<T1, T2, T3, Node> provide) where T1 : IInjectable where T2 : IInjectable where T3 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>(); var result3 = world.Inject<T3>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2) && result3.TryValue(out var value3))
                return provide(value1, value2, value3).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>(), world.Dependencies<T3>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages(), result3.Messages()));
        }));
        public static Node Inject<T1, T2, T3, T4>(Func<T1, T2, T3, T4, Node> provide) where T1 : IInjectable where T2 : IInjectable where T3 : IInjectable where T4 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>(); var result3 = world.Inject<T3>(); var result4 = world.Inject<T4>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2) && result3.TryValue(out var value3) && result4.TryValue(out var value4))
                return provide(value1, value2, value3, value4).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>(), world.Dependencies<T3>(), world.Dependencies<T4>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages(), result3.Messages(), result4.Messages()));
        }));
        public static Node Inject<T1, T2, T3, T4, T5>(Func<T1, T2, T3, T4, T5, Node> provide) where T1 : IInjectable where T2 : IInjectable where T3 : IInjectable where T4 : IInjectable where T5 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>(); var result3 = world.Inject<T3>(); var result4 = world.Inject<T4>(); var result5 = world.Inject<T5>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2) && result3.TryValue(out var value3) && result4.TryValue(out var value4) && result5.TryValue(out var value5))
                return provide(value1, value2, value3, value4, value5).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>(), world.Dependencies<T3>(), world.Dependencies<T4>(), world.Dependencies<T5>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages(), result3.Messages(), result4.Messages(), result5.Messages()));
        }));
        public static Node Inject<T1, T2, T3, T4, T5, T6>(Func<T1, T2, T3, T4, T5, T6, Node> provide) where T1 : IInjectable where T2 : IInjectable where T3 : IInjectable where T4 : IInjectable where T5 : IInjectable where T6 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>(); var result3 = world.Inject<T3>(); var result4 = world.Inject<T4>(); var result5 = world.Inject<T5>(); var result6 = world.Inject<T6>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2) && result3.TryValue(out var value3) && result4.TryValue(out var value4) && result5.TryValue(out var value5) && result6.TryValue(out var value6))
                return provide(value1, value2, value3, value4, value5, value6).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>(), world.Dependencies<T3>(), world.Dependencies<T4>(), world.Dependencies<T5>(), world.Dependencies<T6>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages(), result3.Messages(), result4.Messages(), result5.Messages(), result6.Messages()));
        }));
        public static Node Inject<T1, T2, T3, T4, T5, T6, T7>(Func<T1, T2, T3, T4, T5, T6, T7, Node> provide) where T1 : IInjectable where T2 : IInjectable where T3 : IInjectable where T4 : IInjectable where T5 : IInjectable where T6 : IInjectable where T7 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>(); var result3 = world.Inject<T3>(); var result4 = world.Inject<T4>(); var result5 = world.Inject<T5>(); var result6 = world.Inject<T6>(); var result7 = world.Inject<T7>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2) && result3.TryValue(out var value3) && result4.TryValue(out var value4) && result5.TryValue(out var value5) && result6.TryValue(out var value6) && result7.TryValue(out var value7))
                return provide(value1, value2, value3, value4, value5, value6, value7).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>(), world.Dependencies<T3>(), world.Dependencies<T4>(), world.Dependencies<T5>(), world.Dependencies<T6>(), world.Dependencies<T7>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages(), result3.Messages(), result4.Messages(), result5.Messages(), result6.Messages(), result7.Messages()));
        }));
        public static Node Inject<T1, T2, T3, T4, T5, T6, T7, T8>(Func<T1, T2, T3, T4, T5, T6, T7, T8, Node> provide) where T1 : IInjectable where T2 : IInjectable where T3 : IInjectable where T4 : IInjectable where T5 : IInjectable where T6 : IInjectable where T7 : IInjectable where T8 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>(); var result3 = world.Inject<T3>(); var result4 = world.Inject<T4>(); var result5 = world.Inject<T5>(); var result6 = world.Inject<T6>(); var result7 = world.Inject<T7>(); var result8 = world.Inject<T8>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2) && result3.TryValue(out var value3) && result4.TryValue(out var value4) && result5.TryValue(out var value5) && result6.TryValue(out var value6) && result7.TryValue(out var value7) && result8.TryValue(out var value8))
                return provide(value1, value2, value3, value4, value5, value6, value7, value8).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>(), world.Dependencies<T3>(), world.Dependencies<T4>(), world.Dependencies<T5>(), world.Dependencies<T6>(), world.Dependencies<T7>(), world.Dependencies<T8>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages(), result3.Messages(), result4.Messages(), result5.Messages(), result6.Messages(), result7.Messages(), result8.Messages()));
        }));
        public static Node Inject<T1, T2, T3, T4, T5, T6, T7, T8, T9>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, Node> provide) where T1 : IInjectable where T2 : IInjectable where T3 : IInjectable where T4 : IInjectable where T5 : IInjectable where T6 : IInjectable where T7 : IInjectable where T8 : IInjectable where T9 : IInjectable => From(new Nodes.Lazy(world =>
        {
            var result1 = world.Inject<T1>(); var result2 = world.Inject<T2>(); var result3 = world.Inject<T3>(); var result4 = world.Inject<T4>(); var result5 = world.Inject<T5>(); var result6 = world.Inject<T6>(); var result7 = world.Inject<T7>(); var result8 = world.Inject<T8>(); var result9 = world.Inject<T9>();
            if (result1.TryValue(out var value1) && result2.TryValue(out var value2) && result3.TryValue(out var value3) && result4.TryValue(out var value4) && result5.TryValue(out var value5) && result6.TryValue(out var value6) && result7.TryValue(out var value7) && result8.TryValue(out var value8) && result9.TryValue(out var value9))
                return provide(value1, value2, value3, value4, value5, value6, value7, value8, value9).Depend(new[] { world.Dependencies<T1>(), world.Dependencies<T2>(), world.Dependencies<T3>(), world.Dependencies<T4>(), world.Dependencies<T5>(), world.Dependencies<T6>(), world.Dependencies<T7>(), world.Dependencies<T8>(), world.Dependencies<T9>() }.Flatten());
            else
                return Result.Failure(ArrayUtility.Concatenate(result1.Messages(), result2.Messages(), result3.Messages(), result4.Messages(), result5.Messages(), result6.Messages(), result7.Messages(), result8.Messages(), result9.Messages()));
        }));
    }
}