using System.Collections.Generic;

IEnumerable<(string declaration, string function)> Generate(int depth)
{
    const string message = "TMessage";

    static IEnumerable<string> GenericParameters(int count)
    {
        if (count == 1) yield return "T";
        else for (var i = 1; i <= count; i++) yield return $"T{i}";
    }

    static string Declaration(bool hasMessage, IEnumerable<string> generics, IEnumerable<string> constraints)
    {
        var suffix = hasMessage ? "M" : "";
        var parameters = generics.Select((generic, index) => $"ref {generic} resource{index + 1}");
        if (hasMessage)
        {
            generics = generics.Prepend(message);
            parameters = parameters.Prepend($"in {message} message");
            constraints = constraints.Prepend($"where {message} : struct, IMessage");
        }
        return $"public delegate void Run{suffix}<{string.Join(", ", generics)}>({string.Join(", ", parameters)}) {string.Join(" ", constraints)};";
    }

    static string Body(bool hasMessage, IEnumerable<string> generics, IEnumerable<string> constraints)
    {
        var suffix = hasMessage ? "M" : "";
        var arguments = hasMessage ? generics.Prepend(message) : generics;
        var resourceVars = generics.Select((generic, index) => $"Resource<{generic}> resource{index + 1}");
        var resourceRefs = generics.Select((generic, index) => $"ref resource{index + 1}.Value");
        if (hasMessage) resourceRefs = resourceRefs.Prepend("message");
        var messageParameter = hasMessage ? $"in {message} message" : $"in {message} _";
        return
$@"public static Runner Run<{string.Join(", ", generics)}>(Run{suffix}<{string.Join(", ", arguments)}> run) {string.Join(" ", constraints)} =>
    With(({string.Join(", ", resourceVars)}) => Run(({messageParameter}) => run({string.Join(", ", resourceRefs)})));";
    }

    for (int i = 1; i <= depth; i++)
    {
        var generics = GenericParameters(i).ToArray();
        var constraints = generics.Select((generic, index) => $"where {generic} : struct, IResource");
        var parameters = generics.Select((generic, index) => $"ref resource{index + 1}");

        yield return (Declaration(false, generics, constraints), Body(false, generics, constraints));
        if (i < depth) yield return (Declaration(true, generics, constraints), Body(true, generics, constraints));
    }
}

var results = Generate(7).ToArray();
var file = "Runner.Run";
var code =
$@"/* DO NOT MODIFY: The content of this file has been generated by the script '{file}.csx'. */

using System;
using Entia.Core;
using Entia.Injectables;

namespace Entia.Experimental
{{
    public readonly partial struct Runner
    {{
{string.Join(Environment.NewLine, results.Select(result => result.declaration))}

        public static partial class When<TMessage> where TMessage : struct, IMessage
        {{
            public static Runner Run(InAction<TMessage> run) => new Runner(world => Schedule(run));
            public static Runner Run(Action run) => Run((in TMessage _) => run());
{string.Join(Environment.NewLine, results.Select(result => result.function))}
        }}
    }}
}}";


File.WriteAllText($"./{file}.cs", code);