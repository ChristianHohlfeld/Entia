/* DO NOT MODIFY: The content of this file has been generated by the script 'Runner.RunEach.csx'. */

using System;
using Entia.Core;
using Entia.Modules;
using Entia.Modules.Component;
using Entia.Dependencies;

namespace Entia.Experimental
{
    public readonly partial struct Runner
    {
        public delegate void RunEach<T>(ref T component1) where T : struct, IComponent;
        public delegate void RunEachE<T>(Entity entity, ref T component1) where T : struct, IComponent;
        public delegate void RunEachM<TMessage, T>(in TMessage message, ref T component1) where TMessage : struct, IMessage where T : struct, IComponent;
        public delegate void RunEachME<TMessage, T>(in TMessage message, Entity entity, ref T component1) where TMessage : struct, IMessage where T : struct, IComponent;
        public delegate void RunEach<T1, T2>(ref T1 component1, ref T2 component2) where T1 : struct, IComponent where T2 : struct, IComponent;
        public delegate void RunEachE<T1, T2>(Entity entity, ref T1 component1, ref T2 component2) where T1 : struct, IComponent where T2 : struct, IComponent;
        public delegate void RunEachM<TMessage, T1, T2>(in TMessage message, ref T1 component1, ref T2 component2) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent;
        public delegate void RunEachME<TMessage, T1, T2>(in TMessage message, Entity entity, ref T1 component1, ref T2 component2) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent;
        public delegate void RunEach<T1, T2, T3>(ref T1 component1, ref T2 component2, ref T3 component3) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent;
        public delegate void RunEachE<T1, T2, T3>(Entity entity, ref T1 component1, ref T2 component2, ref T3 component3) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent;
        public delegate void RunEachM<TMessage, T1, T2, T3>(in TMessage message, ref T1 component1, ref T2 component2, ref T3 component3) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent;
        public delegate void RunEachME<TMessage, T1, T2, T3>(in TMessage message, Entity entity, ref T1 component1, ref T2 component2, ref T3 component3) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent;
        public delegate void RunEach<T1, T2, T3, T4>(ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent;
        public delegate void RunEachE<T1, T2, T3, T4>(Entity entity, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent;
        public delegate void RunEachM<TMessage, T1, T2, T3, T4>(in TMessage message, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent;
        public delegate void RunEachME<TMessage, T1, T2, T3, T4>(in TMessage message, Entity entity, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent;
        public delegate void RunEach<T1, T2, T3, T4, T5>(ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent;
        public delegate void RunEachE<T1, T2, T3, T4, T5>(Entity entity, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent;
        public delegate void RunEachM<TMessage, T1, T2, T3, T4, T5>(in TMessage message, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent;
        public delegate void RunEachME<TMessage, T1, T2, T3, T4, T5>(in TMessage message, Entity entity, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent;
        public delegate void RunEach<T1, T2, T3, T4, T5, T6>(ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5, ref T6 component6) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent;
        public delegate void RunEachE<T1, T2, T3, T4, T5, T6>(Entity entity, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5, ref T6 component6) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent;
        public delegate void RunEachM<TMessage, T1, T2, T3, T4, T5, T6>(in TMessage message, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5, ref T6 component6) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent;
        public delegate void RunEachME<TMessage, T1, T2, T3, T4, T5, T6>(in TMessage message, Entity entity, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5, ref T6 component6) where TMessage : struct, IMessage where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent;
        public delegate void RunEach<T1, T2, T3, T4, T5, T6, T7>(ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5, ref T6 component6, ref T7 component7) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent where T7 : struct, IComponent;
        public delegate void RunEachE<T1, T2, T3, T4, T5, T6, T7>(Entity entity, ref T1 component1, ref T2 component2, ref T3 component3, ref T4 component4, ref T5 component5, ref T6 component6, ref T7 component7) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent where T7 : struct, IComponent;

        public static partial class When<TMessage> where TMessage : struct, IMessage
        {
            public static Runner RunEach<T>(RunEach<T> run, params Filter[] filters) where T : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T>();
                        for (int i = 0; i < count; i++) run(ref store1[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T>(out var store1) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(ref store1[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T)));
            });
            public static Runner RunEach<T>(RunEachE<T> run, params Filter[] filters) where T : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T>();
                        for (int i = 0; i < count; i++) run(entities[i], ref store1[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T>(out var store1) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(entities[i], ref store1[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T)));
            });
            public static Runner RunEach<T>(RunEachM<TMessage, T> run, params Filter[] filters) where T : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T>();
                        for (int i = 0; i < count; i++) run(message, ref store1[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T>(out var store1) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, ref store1[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T)));
            });
            public static Runner RunEach<T>(RunEachME<TMessage, T> run, params Filter[] filters) where T : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T>();
                        for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T>(out var store1) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T)));
            });
            public static Runner RunEach<T1, T2>(RunEach<T1, T2> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>();
                        for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)));
            });
            public static Runner RunEach<T1, T2>(RunEachE<T1, T2> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>();
                        for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)));
            });
            public static Runner RunEach<T1, T2>(RunEachM<TMessage, T1, T2> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>();
                        for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)));
            });
            public static Runner RunEach<T1, T2>(RunEachME<TMessage, T1, T2> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>();
                        for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)));
            });
            public static Runner RunEach<T1, T2, T3>(RunEach<T1, T2, T3> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>();
                        for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)));
            });
            public static Runner RunEach<T1, T2, T3>(RunEachE<T1, T2, T3> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>();
                        for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)));
            });
            public static Runner RunEach<T1, T2, T3>(RunEachM<TMessage, T1, T2, T3> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>();
                        for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)));
            });
            public static Runner RunEach<T1, T2, T3>(RunEachME<TMessage, T1, T2, T3> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>();
                        for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)));
            });
            public static Runner RunEach<T1, T2, T3, T4>(RunEach<T1, T2, T3, T4> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>();
                        for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)));
            });
            public static Runner RunEach<T1, T2, T3, T4>(RunEachE<T1, T2, T3, T4> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>();
                        for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)));
            });
            public static Runner RunEach<T1, T2, T3, T4>(RunEachM<TMessage, T1, T2, T3, T4> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>();
                        for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)));
            });
            public static Runner RunEach<T1, T2, T3, T4>(RunEachME<TMessage, T1, T2, T3, T4> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>();
                        for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5>(RunEach<T1, T2, T3, T4, T5> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>();
                        for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5>(RunEachE<T1, T2, T3, T4, T5> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>();
                        for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5>(RunEachM<TMessage, T1, T2, T3, T4, T5> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>();
                        for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5>(RunEachME<TMessage, T1, T2, T3, T4, T5> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>();
                        for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5, T6>(RunEach<T1, T2, T3, T4, T5, T6> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>(); var store6 = segment.Store<T6>();
                        for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && segment.TryStore<T6>(out var store6) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)), new Write(typeof(T6)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5, T6>(RunEachE<T1, T2, T3, T4, T5, T6> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>(); var store6 = segment.Store<T6>();
                        for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && segment.TryStore<T6>(out var store6) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)), new Write(typeof(T6)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5, T6>(RunEachM<TMessage, T1, T2, T3, T4, T5, T6> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>(); var store6 = segment.Store<T6>();
                        for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && segment.TryStore<T6>(out var store6) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)), new Write(typeof(T6)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5, T6>(RunEachME<TMessage, T1, T2, T3, T4, T5, T6> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage message) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>(); var store6 = segment.Store<T6>();
                        for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && segment.TryStore<T6>(out var store6) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(message, entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)), new Write(typeof(T6)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5, T6, T7>(RunEach<T1, T2, T3, T4, T5, T6, T7> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent where T7 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (_, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>(); var store6 = segment.Store<T6>(); var store7 = segment.Store<T7>();
                        for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i], ref store7[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && segment.TryStore<T6>(out var store6) && segment.TryStore<T7>(out var store7) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (_, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i], ref store7[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)), new Write(typeof(T6)), new Write(typeof(T7)));
            });
            public static Runner RunEach<T1, T2, T3, T4, T5, T6, T7>(RunEachE<T1, T2, T3, T4, T5, T6, T7> run, params Filter[] filters) where T1 : struct, IComponent where T2 : struct, IComponent where T3 : struct, IComponent where T4 : struct, IComponent where T5 : struct, IComponent where T6 : struct, IComponent where T7 : struct, IComponent => new Runner(world =>
            {
                var filter = Filter.All(filters);
                var components = world.Components();
                var segments = Array.Empty<Segment>();
                var index = 0;
                return Schedule((in TMessage _) =>
                {
                    foreach (var segment in segments)
                    {
                        var (entities, count) = segment.Entities;
                        var store1 = segment.Store<T1>(); var store2 = segment.Store<T2>(); var store3 = segment.Store<T3>(); var store4 = segment.Store<T4>(); var store5 = segment.Store<T5>(); var store6 = segment.Store<T6>(); var store7 = segment.Store<T7>();
                        for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i], ref store7[i]);
                    }

                    while (index < components.Segments.Length)
                    {
                        var segment = components.Segments[index++];
                        if (segment.TryStore<T1>(out var store1) && segment.TryStore<T2>(out var store2) && segment.TryStore<T3>(out var store3) && segment.TryStore<T4>(out var store4) && segment.TryStore<T5>(out var store5) && segment.TryStore<T6>(out var store6) && segment.TryStore<T7>(out var store7) && filter.Match(segment))
                        {
                            ArrayUtility.Add(ref segments, components.Segments[index++]);
                            var (entities, count) = segment.Entities;
                            for (int i = 0; i < count; i++) run(entities[i], ref store1[i], ref store2[i], ref store3[i], ref store4[i], ref store5[i], ref store6[i], ref store7[i]);
                        }
                    }
                }, new Read(typeof(Entity)), new Write(typeof(T1)), new Write(typeof(T2)), new Write(typeof(T3)), new Write(typeof(T4)), new Write(typeof(T5)), new Write(typeof(T6)), new Write(typeof(T7)));
            });
        }
    }
}