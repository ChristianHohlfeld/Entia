using System.Collections.Generic;

IEnumerable<(string declaration, string run)> Generate(int depth)
{
    const string message = "TMessage";

    static IEnumerable<string> GenericParameters(int count)
    {
        if (count == 1) yield return "T";
        else for (var i = 1; i <= count; i++) yield return $"T{i}";
    }

    static string Declaration(string suffix, IEnumerable<string> generics, IEnumerable<string> parameters, IEnumerable<string> constraints) =>
        $"public delegate void RunEach{suffix}<{string.Join(", ", generics)}>({string.Join(", ", parameters)}) {string.Join(" ", constraints)};";

    static string Body(string suffix, bool hasEntity, bool hasMessage, IEnumerable<string> generics, IEnumerable<string> constraints)
    {
        IEnumerable<string> Arguments()
        {
            if (hasMessage) yield return "message";
            if (hasEntity) yield return "entities[i]";
        }

        var runGenerics = hasMessage ? generics.Prepend(message) : generics;
        var runEach = $"RunEach{suffix}<{string.Join(", ", runGenerics)}>";
        var messageParameter = hasMessage ? $"in {message} message" : $"in {message} _";
        var storeVars = generics.Select((generic, index) => $"var store{index + 1} = segment.Store<{generic}>();");
        var storeRefs = generics.Select((generic, index) => $"ref store{index + 1}[i]");
        var storeTries = generics.Select((generic, index) => $"segment.TryStore<{generic}>(out var store{index + 1})");
        var dependencies = generics.Select(generic => $"new Write(typeof({generic}))");
        var entitiesVar = hasEntity ? "var (entities, count) = segment.Entities;" : "var (_, count) = segment.Entities;";
        var arguments = Arguments().Concat(storeRefs);
        var forRun = $"for (int i = 0; i < count; i++) run({string.Join(", ", arguments)});";

        return
$@"public static Runner RunEach<{string.Join(", ", generics)}>({runEach} run, params Filter[] filters) {string.Join(" ", constraints)} => new Runner(world =>
{{
    var filter = Filter.All(filters);
    var components = world.Components();
    var segments = Array.Empty<Segment>();
    var index = 0;
    return Schedule(({messageParameter}) =>
    {{
        foreach (var segment in segments)
        {{
            {entitiesVar}
            {string.Join(" ", storeVars)}
            {forRun}
        }}

        while (index < components.Segments.Length)
        {{
            var segment = components.Segments[index++];
            if ({string.Join(" && ", storeTries)} && filter.Match(segment))
            {{
                ArrayUtility.Add(ref segments, components.Segments[index++]);
                {entitiesVar}
                {forRun}
            }}
        }}
    }}, new Read(typeof(Entity)), {string.Join(", ", dependencies)});
}});";
    }

    for (int i = 1; i <= depth; i++)
    {
        var generics = GenericParameters(i).ToArray();
        var parameters = generics.Select((generic, index) => $"ref {generic} component{index + 1}");
        var constraints = generics.Select((generic, index) => $"where {generic} : struct, IComponent");
        var entityParameter = $"Entity entity";
        var messageParameter = $"in {message} message";
        var messageConstraint = $"where {message} : struct, IMessage";

        yield return (
            Declaration("", generics, parameters, constraints),
            Body("", false, false, generics, constraints));
        yield return (
            Declaration("E", generics, parameters.Prepend(entityParameter), constraints),
            Body("E", true, false, generics, constraints));

        if (i < depth)
        {
            yield return (
                Declaration("M", generics.Prepend(message), parameters.Prepend(messageParameter), constraints.Prepend(messageConstraint)),
                Body("M", false, true, generics, constraints));
            yield return (
                Declaration("ME", generics.Prepend(message), parameters.Prepend(entityParameter).Prepend(messageParameter), constraints.Prepend(messageConstraint)),
                Body("ME", true, true, generics, constraints));
        }
    }
}

var file = "Runner.RunEach";
var results = Generate(7).ToArray();
var code =
$@"/* DO NOT MODIFY: The content of this file has been generated by the script '{file}.csx'. */

using System;
using Entia.Core;
using Entia.Modules;
using Entia.Modules.Component;
using Entia.Dependencies;

namespace Entia.Experimental
{{
    public readonly partial struct Runner
    {{
{string.Join(Environment.NewLine, results.Select(result => result.declaration))}

        public static partial class When<TMessage> where TMessage : struct, IMessage
        {{
{string.Join(Environment.NewLine, results.Select(result => result.run))}
        }}
    }}
}}";


File.WriteAllText($"./{file}.cs", code);