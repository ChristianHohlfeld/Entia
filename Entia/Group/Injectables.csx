using System;
using System.Collections.Generic;
using System.Linq;

IEnumerable<string> Generate(int depth)
{
    static IEnumerable<string> GenericParameters(int count)
    {
        if (count == 1) yield return "T";
        else for (var i = 1; i <= count; i++) yield return $"T{i}";
    }

    for (var i = 1; i <= depth; i++)
    {
        var generics = GenericParameters(i).ToArray();
        var parameters = generics.Length == 0 ? "" : $"<{string.Join(", ", generics)}>";
        var itemType =
            generics.Length == 0 ? "Entity" :
            generics.Length == 1 ? string.Join(", ", generics) :
            $"All<{string.Join(", ", generics)}>";
        var documentationType =
            generics.Length == 0 ? "Group" :
            $"Group{{{string.Join(", ", generics)}}}";
        var groupType = $"Modules.Group.Group<{itemType}>";
        var constraints = string.Join(" ", generics.Select(generic => $"where {generic} : struct, IQueryable"));

        yield return
$@"    /// <summary>
    /// Gives access to group operations.
    /// </summary>
    [ThreadSafe]
    public sealed class Group{parameters} : IInjectable, IEnumerable<{groupType}.Enumerator, {itemType}> {constraints}
    {{
        [Implementation]
        static Injector<object> _injector => Injector.From<object>(context => new Group{parameters}(context.World.Groups().Get<{itemType}>(context.Member)));
        [Implementation]
        static IDepender _depender => Depender.From<{itemType}>(new Dependencies.Read(typeof(Entity)));

        /// <inheritdoc cref=""Modules.Group.Group{{T}}.Count""/>
        public int Count => _group.Count;
        /// <inheritdoc cref=""Modules.Group.Group{{T}}.Segments""/>
        public Segment<{itemType}>[] Segments => _group.Segments;
        /// <inheritdoc cref=""Modules.Group.Group{{T}}.Entities""/>
        public {groupType}.EntityEnumerable Entities => _group.Entities;

        readonly {groupType} _group;

        /// <summary>
        /// Initializes a new instance of the <see cref=""{documentationType}""/> class.
        /// </summary>
        /// <param name=""group"">The group.</param>
        public Group({groupType} group) {{ _group = group; }}
        /// <inheritdoc cref=""Modules.Group.Group{{T}}.Has(Entity)""/>
        public bool Has(Entity entity) => _group.Has(entity);
        /// <inheritdoc cref=""Modules.Group.Group{{T}}.TryGet(Entity, out T)""/>
        public bool TryGet(Entity entity, out {itemType} item) => _group.TryGet(entity, out item);
        /// <inheritdoc cref=""Modules.Group.Group{{T}}.Get(Entity, out bool)""/>
        public ref readonly {itemType} Get(Entity entity, out bool success) => ref _group.Get(entity, out success);
        /// <inheritdoc cref=""Modules.Group.Group{{T}}.Split(int)""/>
        public {groupType}.SplitEnumerable Split(int count) => _group.Split(count);
        /// <inheritdoc cref=""Modules.Group.Group{{T}}.GetEnumerator""/>
        public {groupType}.Enumerator GetEnumerator() => _group.GetEnumerator();
        IEnumerator<{itemType}> IEnumerable<{itemType}>.GetEnumerator() => GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }}
";
    }
}

var file = "Injectables";
var code =
$@"/* DO NOT MODIFY: The content of this file has been generated by the script '{file}.csx'. */

using Entia.Core;
using Entia.Core.Documentation;
using Entia.Dependers;
using Entia.Injectors;
using Entia.Modules;
using Entia.Modules.Group;
using Entia.Queryables;
using System.Collections;
using System.Collections.Generic;

namespace Entia.Injectables
{{
{string.Join(Environment.NewLine, Generate(7))}
}}";

File.WriteAllText($"./{file}.cs", code);